import numpy as np
from tqdm import tqdm
from qiskit import  QuantumCircuit,transpile
from qiskit.providers.aer import QasmSimulator

def qke(x1,x2,kernel,layer=5, backend=QasmSimulator(),shots=1000):
    gate1,n_qubits = kernel(x1,layer)
    qc = QuantumCircuit(n_qubits)
    for i in range(layer):
        gate1,n_qubits = kernel([j*3**i for j in x1],layer)
        qc.append(gate1.to_gate(),range(n_qubits))    

    for i in range(layer):
        gate2 = QuantumCircuit.inverse(kernel([j*3**i for j in x2],layer)[0])
        qc.append(gate2.to_gate(),range(n_qubits))
    qc.measure_all()
    
    qc_compiled = transpile(qc, backend)
    job = backend.run(qc_compiled, shots=shots)
    counts = job.result().get_counts ()
    
    string = ""
    for k in range(n_qubits) : string += "0"
    if (string in counts.keys()): return(counts[string]/shots)
    else : return(0)

def qke_multi(x1,x2,kernel,layer=1, backend=QasmSimulator(),shots=1000):
    n = len(x1)
    k = n//32
    qc = QuantumCircuit(8)
    for j in range(layer):
        for i in range(k):
            x_temp = [k*3**j for k in x1[i*32:(i+1)*32]]
            gate1,n_qubits = kernel(x_temp,layer)
            qc.append(gate1,range(8))
        x_temp = [k*3**j for k in x1[k*32:n]]
        gate1,n_qubits = kernel(x_temp,layer)
        qc.append(gate1,range(n_qubits))

    for j in range(layer):
        x_temp = [k*3**j for k in x2[k*32:n]]
        gate2 = QuantumCircuit.inverse(kernel(x_temp,layer)[0])
        qc.append(gate2,range(n_qubits))
        for i in range(k-1,-1,-1):
            x_temp = [k*3**j for k in x2[i*32:(i+1)*32]]
            gate2 = QuantumCircuit.inverse(kernel(x_temp,layer)[0])
            qc.append(gate2,range(8))
    qc.measure_all()
    shots = 5000
    qc_compiled = transpile(qc, backend=QasmSimulator())
    backend=QasmSimulator()
    job = backend.run(qc_compiled, shots=shots)
    counts = job.result().get_counts()
    string = ""
    for k in range(8) : string += "0"
    if (string in counts.keys()): return(counts[string]/shots)
    else : return(0)


def get_gram(data,kernel_fun,layer,backend = QasmSimulator(),shots=1000):
    n = len(data)
    gram_matrix = np.identity(n)
    for i in tqdm(range(n)):
        for j in range(i):
            gram_matrix[i,j] = qke(data.iloc[i,:].tolist(),data.iloc[j,:].tolist(),kernel_fun,layer,backend,shots=shots)
            gram_matrix[j,i] = gram_matrix[i,j]
    return(gram_matrix)

def get_gram_test(data,test_data,kernel_fun,layer,backend = QasmSimulator(),shots=1000):
    n = len(data)
    m = len(test_data)
    gram_matrix = np.empty(shape=(n,m))
    for i in tqdm(range(n)):
        for j in range(m):
            gram_matrix[i,j] = qke(data.iloc[i,:].tolist(),test_data.iloc[j,:].tolist(),kernel_fun,layer,backend,shots=shots)
    return(gram_matrix)

def get_gram_multi(data,kernel_fun,layer,backend = QasmSimulator(),shots=1000):
    n = len(data)
    gram_matrix = np.identity(n)
    for i in tqdm(range(n)):
        for j in range(i):
            gram_matrix[i,j] = qke_multi(data.iloc[i,:].tolist(),data.iloc[j,:].tolist(),kernel_fun,layer,backend,shots=shots)
            gram_matrix[j,i] = gram_matrix[i,j]
    return(gram_matrix)

def get_gram_test_multi(data,test_data,kernel_fun,layer,backend = QasmSimulator(),shots=1000):
    n = len(data)
    m = len(test_data)
    gram_matrix = np.empty(shape=(n,m))
    for i in tqdm(range(n)):
        for j in range(m):
            gram_matrix[i,j] = qke_multi(data.iloc[i,:].tolist(),test_data.iloc[j,:].tolist(),kernel_fun,layer,backend,shots=shots)
    return(gram_matrix)

def Gram_discrete(data,version="H") :  
    n = data.shape[0]
    J = np.outer(np.ones(shape=(n,1)),np.ones(shape=(n,1)))
    Q = np.identity(n)-J/n
    K = [[1 if i==j else 0 for j in data] for i in data]
    dis = np.matmul(np.matmul(Q,K),Q)
    return(dis)

def Gram_gaussian(data,comp) :
    n = data.shape[0];p = data.shape[1] 
    U = np.matmul(data,data.T)
    M = np.outer(np.diag(U),np.ones(shape=(n,1)))
    K = M+M.T-2*U
    K[K<0] = 0 
    sigma = (np.sum(np.sqrt(K))-np.trace(np.sqrt(K)))/n/(n-1)
    gamma = comp/sigma/sigma
    result = np.exp(-K*gamma)
    return(result)

def Gram_gaussian_test(data1,data2,comp) :
    n = data1.shape[0];p = data1.shape[1] 
    m = data2.shape[0]

    U = np.matmul(data1,data1.T)
    M = np.outer(np.diag(U),np.ones(shape=(n,1)))
    K = M+M.T-2*U
    K[K<0] = 0 
    M_new = np.outer(np.diag(U),np.ones(shape=(m,1)))
    U_new = np.matmul(data1,data2.T)
    T_new = np.outer(np.diag(np.matmul(data2,data2.T)),np.ones(shape=(n,1)))
    K_new = M_new+T_new.T-2*U_new

    sigma = (np.sum(np.sqrt(K))-np.trace(np.sqrt(K)))/n/(n-1)
    gamma = comp/sigma/sigma
    result = np.exp(-K_new*gamma)
    return(result)